"""
Vulnerability Scanner Module

Scans dependencies for known security vulnerabilities:
- Python (requirements.txt, pyproject.toml, setup.py)
- JavaScript (package.json, package-lock.json)
- Rust (Cargo.toml, Cargo.lock)

Uses multiple data sources:
- Safety DB (Python)
- OSV (Open Source Vulnerabilities)
- GitHub Advisory Database
- NVD (National Vulnerability Database)
"""

import os
import json
import re
import subprocess
import logging
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Set
from pathlib import Path
from enum import Enum
import requests
from packaging.version import parse as parse_version, Version

logger = logging.getLogger(__name__)


class Severity(str, Enum):
    """Vulnerability severity levels."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    UNKNOWN = "UNKNOWN"

    @classmethod
    def from_score(cls, score: float) -> 'Severity':
        """Convert CVSS score to severity level."""
        if score >= 9.0:
            return cls.CRITICAL
        elif score >= 7.0:
            return cls.HIGH
        elif score >= 4.0:
            return cls.MEDIUM
        elif score > 0:
            return cls.LOW
        else:
            return cls.UNKNOWN

    @classmethod
    def from_string(cls, severity: str) -> 'Severity':
        """Parse severity from string."""
        severity_upper = severity.upper()
        try:
            return cls(severity_upper)
        except ValueError:
            return cls.UNKNOWN


@dataclass
class Vulnerability:
    """Represents a single vulnerability."""
    package_name: str
    installed_version: str
    vulnerability_id: str  # CVE ID or advisory ID
    severity: Severity
    title: str
    description: str
    affected_versions: str = ""
    fixed_version: Optional[str] = None
    published_date: Optional[str] = None
    references: List[str] = field(default_factory=list)
    cvss_score: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            'package_name': self.package_name,
            'installed_version': self.installed_version,
            'vulnerability_id': self.vulnerability_id,
            'severity': self.severity.value,
            'title': self.title,
            'description': self.description,
            'affected_versions': self.affected_versions,
            'fixed_version': self.fixed_version,
            'published_date': self.published_date,
            'references': self.references,
            'cvss_score': self.cvss_score,
        }

    @property
    def fix_recommendation(self) -> str:
        """Generate fix recommendation."""
        if self.fixed_version:
            return f"Upgrade {self.package_name} from {self.installed_version} to {self.fixed_version}"
        else:
            return f"No fix available yet for {self.package_name}. Monitor {self.vulnerability_id} for updates."


@dataclass
class VulnerabilityReport:
    """Complete vulnerability scan report."""
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    total_scanned: int = 0
    summary: Dict[str, int] = field(default_factory=dict)
    scan_timestamp: Optional[str] = None
    scanned_files: List[str] = field(default_factory=list)

    def __post_init__(self):
        """Calculate summary statistics."""
        self.summary = {
            'total_vulnerabilities': len(self.vulnerabilities),
            'critical': sum(1 for v in self.vulnerabilities if v.severity == Severity.CRITICAL),
            'high': sum(1 for v in self.vulnerabilities if v.severity == Severity.HIGH),
            'medium': sum(1 for v in self.vulnerabilities if v.severity == Severity.MEDIUM),
            'low': sum(1 for v in self.vulnerabilities if v.severity == Severity.LOW),
            'unknown': sum(1 for v in self.vulnerabilities if v.severity == Severity.UNKNOWN),
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            'summary': self.summary,
            'total_scanned': self.total_scanned,
            'scan_timestamp': self.scan_timestamp,
            'scanned_files': self.scanned_files,
            'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
        }

    def get_by_severity(self, severity: Severity) -> List[Vulnerability]:
        """Get vulnerabilities filtered by severity."""
        return [v for v in self.vulnerabilities if v.severity == severity]


class VulnerabilityScanner:
    """
    Multi-language vulnerability scanner.

    Supports:
    - Python: requirements.txt, pyproject.toml
    - JavaScript: package.json
    - Rust: Cargo.toml
    """

    def __init__(self):
        """Initialize the vulnerability scanner."""
        self.osv_api_url = "https://api.osv.dev/v1/query"
        self.github_api_url = "https://api.github.com/advisories"

    def scan_repository(self, repo_path: str) -> VulnerabilityReport:
        """
        Scan a repository for vulnerabilities in all supported languages.

        Args:
            repo_path: Path to the repository root

        Returns:
            VulnerabilityReport with all detected vulnerabilities
        """
        from datetime import datetime

        repo_path = Path(repo_path)

        if not repo_path.exists():
            raise ValueError(f"Repository path does not exist: {repo_path}")

        all_vulnerabilities: List[Vulnerability] = []
        scanned_files: List[str] = []
        total_packages = 0

        # Scan Python dependencies
        python_vulns, python_files, python_count = self._scan_python(repo_path)
        all_vulnerabilities.extend(python_vulns)
        scanned_files.extend(python_files)
        total_packages += python_count

        # Scan JavaScript dependencies
        js_vulns, js_files, js_count = self._scan_javascript(repo_path)
        all_vulnerabilities.extend(js_vulns)
        scanned_files.extend(js_files)
        total_packages += js_count

        # Scan Rust dependencies
        rust_vulns, rust_files, rust_count = self._scan_rust(repo_path)
        all_vulnerabilities.extend(rust_vulns)
        scanned_files.extend(rust_files)
        total_packages += rust_count

        report = VulnerabilityReport(
            vulnerabilities=all_vulnerabilities,
            total_scanned=total_packages,
            scanned_files=scanned_files,
            scan_timestamp=datetime.utcnow().isoformat(),
        )

        logger.info(
            f"Vulnerability scan complete: {len(all_vulnerabilities)} "
            f"vulnerabilities found in {total_packages} packages"
        )

        return report

    def _scan_python(self, repo_path: Path) -> tuple[List[Vulnerability], List[str], int]:
        """Scan Python dependencies for vulnerabilities."""
        vulnerabilities = []
        scanned_files = []
        package_count = 0

        # Find Python dependency files
        dep_files = []
        for pattern in ["requirements.txt", "requirements/*.txt", "pyproject.toml"]:
            dep_files.extend(repo_path.glob(pattern))

        for dep_file in dep_files:
            scanned_files.append(str(dep_file))

            try:
                if dep_file.name == "requirements.txt" or dep_file.suffix == ".txt":
                    vulns, count = self._scan_python_requirements(dep_file)
                    vulnerabilities.extend(vulns)
                    package_count += count
                elif dep_file.name == "pyproject.toml":
                    vulns, count = self._scan_python_pyproject(dep_file)
                    vulnerabilities.extend(vulns)
                    package_count += count
            except Exception as e:
                logger.warning(f"Failed to scan {dep_file}: {e}")

        return vulnerabilities, scanned_files, package_count

    def _scan_python_requirements(self, req_file: Path) -> tuple[List[Vulnerability], int]:
        """Scan a requirements.txt file."""
        vulnerabilities = []
        packages = self._parse_requirements(req_file)

        for package_name, version in packages.items():
            if version:
                vulns = self._query_osv_vulnerabilities(package_name, version, "PyPI")
                vulnerabilities.extend(vulns)

        return vulnerabilities, len(packages)

    def _scan_python_pyproject(self, pyproject_file: Path) -> tuple[List[Vulnerability], int]:
        """Scan a pyproject.toml file."""
        try:
            import tomli
        except ImportError:
            try:
                import tomllib as tomli
            except ImportError:
                logger.warning("tomli/tomllib not available, skipping pyproject.toml")
                return [], 0

        vulnerabilities = []

        with open(pyproject_file, 'rb') as f:
            data = tomli.load(f)

        # Extract dependencies
        packages = {}

        # PEP 621 style
        if 'project' in data and 'dependencies' in data['project']:
            for dep in data['project']['dependencies']:
                name, version = self._parse_dependency_spec(dep)
                if name:
                    packages[name] = version

        # Poetry style
        if 'tool' in data and 'poetry' in data['tool']:
            deps = data['tool']['poetry'].get('dependencies', {})
            for name, spec in deps.items():
                if name == 'python':
                    continue
                if isinstance(spec, str):
                    packages[name] = spec.lstrip('^~>=<')
                elif isinstance(spec, dict):
                    packages[name] = spec.get('version', '').lstrip('^~>=<')

        # Query vulnerabilities
        for package_name, version in packages.items():
            if version:
                vulns = self._query_osv_vulnerabilities(package_name, version, "PyPI")
                vulnerabilities.extend(vulns)

        return vulnerabilities, len(packages)

    def _scan_javascript(self, repo_path: Path) -> tuple[List[Vulnerability], List[str], int]:
        """Scan JavaScript/Node.js dependencies."""
        vulnerabilities = []
        scanned_files = []
        package_count = 0

        # Find package.json files
        package_files = list(repo_path.glob("**/package.json"))

        for package_file in package_files:
            # Skip node_modules directories
            if 'node_modules' in str(package_file):
                continue

            scanned_files.append(str(package_file))

            try:
                vulns, count = self._scan_package_json(package_file)
                vulnerabilities.extend(vulns)
                package_count += count
            except Exception as e:
                logger.warning(f"Failed to scan {package_file}: {e}")

        return vulnerabilities, scanned_files, package_count

    def _scan_package_json(self, package_file: Path) -> tuple[List[Vulnerability], int]:
        """Scan a package.json file."""
        vulnerabilities = []

        with open(package_file, 'r', encoding='utf-8') as f:
            data = json.load(f)

        packages = {}

        # Merge dependencies and devDependencies
        for dep_type in ['dependencies', 'devDependencies']:
            if dep_type in data:
                packages.update(data[dep_type])

        # Query vulnerabilities
        for package_name, version_spec in packages.items():
            # Clean version spec (remove ^, ~, etc.)
            version = version_spec.lstrip('^~>=<')
            vulns = self._query_osv_vulnerabilities(package_name, version, "npm")
            vulnerabilities.extend(vulns)

        return vulnerabilities, len(packages)

    def _scan_rust(self, repo_path: Path) -> tuple[List[Vulnerability], List[str], int]:
        """Scan Rust dependencies."""
        vulnerabilities = []
        scanned_files = []
        package_count = 0

        # Find Cargo.toml files
        cargo_files = list(repo_path.glob("**/Cargo.toml"))

        for cargo_file in cargo_files:
            scanned_files.append(str(cargo_file))

            try:
                vulns, count = self._scan_cargo_toml(cargo_file)
                vulnerabilities.extend(vulns)
                package_count += count
            except Exception as e:
                logger.warning(f"Failed to scan {cargo_file}: {e}")

        return vulnerabilities, scanned_files, package_count

    def _scan_cargo_toml(self, cargo_file: Path) -> tuple[List[Vulnerability], int]:
        """Scan a Cargo.toml file."""
        try:
            import tomli
        except ImportError:
            try:
                import tomllib as tomli
            except ImportError:
                logger.warning("tomli/tomllib not available, skipping Cargo.toml")
                return [], 0

        vulnerabilities = []

        with open(cargo_file, 'rb') as f:
            data = tomli.load(f)

        packages = {}

        # Extract dependencies
        for dep_type in ['dependencies', 'dev-dependencies']:
            if dep_type in data:
                for name, spec in data[dep_type].items():
                    if isinstance(spec, str):
                        packages[name] = spec
                    elif isinstance(spec, dict):
                        packages[name] = spec.get('version', '')

        # Query vulnerabilities
        for package_name, version in packages.items():
            if version:
                vulns = self._query_osv_vulnerabilities(package_name, version, "crates.io")
                vulnerabilities.extend(vulns)

        return vulnerabilities, len(packages)

    def _query_osv_vulnerabilities(
        self, package_name: str, version: str, ecosystem: str
    ) -> List[Vulnerability]:
        """
        Query OSV (Open Source Vulnerabilities) database.

        Args:
            package_name: Package name
            version: Package version
            ecosystem: Package ecosystem (PyPI, npm, crates.io, etc.)

        Returns:
            List of vulnerabilities found
        """
        vulnerabilities = []

        try:
            payload = {
                "package": {
                    "name": package_name,
                    "ecosystem": ecosystem,
                },
                "version": version,
            }

            response = requests.post(
                self.osv_api_url,
                json=payload,
                timeout=10,
            )

            if response.status_code == 200:
                data = response.json()
                vulns = data.get('vulns', [])

                for vuln_data in vulns:
                    vuln = self._parse_osv_vulnerability(
                        vuln_data, package_name, version
                    )
                    if vuln:
                        vulnerabilities.append(vuln)

        except Exception as e:
            logger.warning(
                f"Failed to query OSV for {package_name}@{version}: {e}"
            )

        return vulnerabilities

    def _parse_osv_vulnerability(
        self, vuln_data: Dict[str, Any], package_name: str, version: str
    ) -> Optional[Vulnerability]:
        """Parse OSV vulnerability data into Vulnerability object."""
        vuln_id = vuln_data.get('id', 'UNKNOWN')

        # Extract CVE ID if available
        cve_id = None
        aliases = vuln_data.get('aliases', [])
        for alias in aliases:
            if alias.startswith('CVE-'):
                cve_id = alias
                break

        # Use CVE ID if available, otherwise use OSV ID
        vulnerability_id = cve_id or vuln_id

        # Extract severity
        severity = Severity.UNKNOWN
        cvss_score = None

        if 'severity' in vuln_data:
            severity_list = vuln_data['severity']
            if severity_list:
                severity_data = severity_list[0]
                if 'score' in severity_data:
                    cvss_score = float(severity_data['score'])
                    severity = Severity.from_score(cvss_score)
                elif 'type' in severity_data:
                    severity = Severity.from_string(severity_data['type'])

        # Extract summary/details
        summary = vuln_data.get('summary', '')
        details = vuln_data.get('details', '')
        title = summary or details[:100] + "..." if details else vulnerability_id

        # Extract affected versions
        affected_versions = ""
        affected = vuln_data.get('affected', [])
        if affected:
            ranges = affected[0].get('ranges', [])
            if ranges:
                range_info = ranges[0]
                events = range_info.get('events', [])
                affected_versions = str(events)

        # Extract fixed version
        fixed_version = None
        if affected:
            fixed = affected[0].get('database_specific', {}).get('fixed_versions', [])
            if fixed:
                fixed_version = fixed[0]

        # Extract references
        references = []
        refs = vuln_data.get('references', [])
        for ref in refs:
            if 'url' in ref:
                references.append(ref['url'])

        # Extract published date
        published_date = vuln_data.get('published', '')

        return Vulnerability(
            package_name=package_name,
            installed_version=version,
            vulnerability_id=vulnerability_id,
            severity=severity,
            title=title,
            description=details or summary,
            affected_versions=affected_versions,
            fixed_version=fixed_version,
            published_date=published_date,
            references=references,
            cvss_score=cvss_score,
        )

    def _parse_requirements(self, req_file: Path) -> Dict[str, Optional[str]]:
        """Parse a requirements.txt file."""
        packages = {}

        with open(req_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()

                # Skip comments and empty lines
                if not line or line.startswith('#'):
                    continue

                # Skip -r, -e, etc.
                if line.startswith('-'):
                    continue

                # Parse package specification
                name, version = self._parse_dependency_spec(line)
                if name:
                    packages[name] = version

        return packages

    def _parse_dependency_spec(self, spec: str) -> tuple[Optional[str], Optional[str]]:
        """
        Parse a dependency specification.

        Examples:
            requests==2.28.0 -> ("requests", "2.28.0")
            flask>=2.0.0 -> ("flask", "2.0.0")
            django~=4.0 -> ("django", "4.0")
        """
        # Trim whitespace
        spec = spec.strip()

        # Extract name/extras/version in one pass so extras don't drop the version
        match = re.match(
            r'^(?P<name>[A-Za-z0-9_.-]+)(?:\[[^\]]+\])?(?P<op>===|==|~=|>=|<=|>|<|!=)?(?P<ver>.*)?$',
            spec
        )
        if match:
            name = match.group('name')
            version = match.group('ver').strip() if match.group('ver') else None
            # Clean leading operators from version (e.g., "~=1.2" -> "1.2")
            if version:
                version = version.lstrip('^~>=<!')
            return name, version or None

        # Fallback: no version/operator detected
        return spec.strip(), None
