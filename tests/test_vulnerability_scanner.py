"""
Integration tests for VulnerabilityScanner
"""

import os
import json
import tempfile
import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock

from src.security.vulnerability_scanner import (
    VulnerabilityScanner,
    VulnerabilityReport,
    Vulnerability,
    Severity,
)


class TestVulnerabilityScanner(unittest.TestCase):
    """Test cases for VulnerabilityScanner"""

    def setUp(self):
        """Set up test fixtures"""
        self.scanner = VulnerabilityScanner()
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Clean up test fixtures"""
        import shutil
        if os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)

    def _create_file(self, filename: str, content: str) -> str:
        """Helper to create a test file"""
        filepath = os.path.join(self.temp_dir, filename)
        # Create parent directories if needed
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, 'w') as f:
            f.write(content)
        return filepath

    def test_severity_from_score(self):
        """Test Severity conversion from CVSS score"""
        self.assertEqual(Severity.from_score(9.5), Severity.CRITICAL)
        self.assertEqual(Severity.from_score(7.5), Severity.HIGH)
        self.assertEqual(Severity.from_score(5.0), Severity.MEDIUM)
        self.assertEqual(Severity.from_score(2.0), Severity.LOW)
        self.assertEqual(Severity.from_score(0.0), Severity.UNKNOWN)

    def test_severity_from_string(self):
        """Test Severity parsing from string"""
        self.assertEqual(Severity.from_string("CRITICAL"), Severity.CRITICAL)
        self.assertEqual(Severity.from_string("high"), Severity.HIGH)
        self.assertEqual(Severity.from_string("Medium"), Severity.MEDIUM)
        self.assertEqual(Severity.from_string("unknown_severity"), Severity.UNKNOWN)

    def test_parse_requirements_txt(self):
        """Test parsing of requirements.txt"""
        content = """
# This is a comment
requests==2.28.0
flask>=2.0.0
django~=4.0
numpy

# Another comment
-e git+https://github.com/user/repo.git#egg=package
"""
        self._create_file("requirements.txt", content)

        packages = self.scanner._parse_requirements(
            Path(os.path.join(self.temp_dir, "requirements.txt"))
        )

        self.assertIn("requests", packages)
        self.assertEqual(packages["requests"], "2.28.0")
        self.assertIn("flask", packages)
        self.assertEqual(packages["flask"], "2.0.0")
        self.assertIn("django", packages)
        self.assertIn("numpy", packages)

    def test_parse_dependency_spec(self):
        """Test parsing of dependency specifications"""
        test_cases = [
            ("requests==2.28.0", ("requests", "2.28.0")),
            ("flask>=2.0.0", ("flask", "2.0.0")),
            ("django~=4.0", ("django", "4.0")),
            ("numpy", ("numpy", None)),
            ("package[extra]==1.0", ("package", "1.0")),
        ]

        for spec, expected in test_cases:
            result = self.scanner._parse_dependency_spec(spec)
            self.assertEqual(result, expected, f"Failed for spec: {spec}")

    def test_scan_python_requirements(self):
        """Test scanning Python requirements.txt"""
        content = """
requests==2.25.0
flask==1.1.0
"""
        self._create_file("requirements.txt", content)

        with patch.object(
            self.scanner,
            '_query_osv_vulnerabilities',
            return_value=[]
        ) as mock_query:
            vulns, scanned_files, count = self.scanner._scan_python(Path(self.temp_dir))

            # Should have called query for each package
            self.assertEqual(mock_query.call_count, 2)
            self.assertGreater(len(scanned_files), 0)
            self.assertEqual(count, 2)

    def test_scan_package_json(self):
        """Test scanning package.json"""
        content = {
            "name": "test-project",
            "version": "1.0.0",
            "dependencies": {
                "express": "^4.17.0",
                "lodash": "4.17.20"
            },
            "devDependencies": {
                "jest": "^27.0.0"
            }
        }
        self._create_file("package.json", json.dumps(content, indent=2))

        with patch.object(
            self.scanner,
            '_query_osv_vulnerabilities',
            return_value=[]
        ) as mock_query:
            vulns, count = self.scanner._scan_package_json(
                Path(os.path.join(self.temp_dir, "package.json"))
            )

            # Should query for all dependencies (3 total)
            self.assertEqual(mock_query.call_count, 3)

    def test_scan_cargo_toml(self):
        """Test scanning Cargo.toml"""
        content = """
[package]
name = "test-project"
version = "0.1.0"

[dependencies]
serde = "1.0"
tokio = { version = "1.0", features = ["full"] }

[dev-dependencies]
proptest = "1.0"
"""
        self._create_file("Cargo.toml", content)

        with patch.object(
            self.scanner,
            '_query_osv_vulnerabilities',
            return_value=[]
        ) as mock_query:
            vulns, count = self.scanner._scan_cargo_toml(
                Path(os.path.join(self.temp_dir, "Cargo.toml"))
            )

            # Should query for dependencies
            self.assertGreater(mock_query.call_count, 0)

    @patch('requests.post')
    def test_query_osv_vulnerabilities_with_results(self, mock_post):
        """Test OSV query with vulnerability results"""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "vulns": [
                {
                    "id": "GHSA-xxxx-yyyy-zzzz",
                    "aliases": ["CVE-2021-12345"],
                    "summary": "Test vulnerability",
                    "details": "This is a test vulnerability",
                    "severity": [
                        {"type": "CVSS_V3", "score": 7.5}
                    ],
                    "affected": [
                        {
                            "ranges": [{"events": [{"introduced": "0"}, {"fixed": "2.0.0"}]}],
                            "database_specific": {"fixed_versions": ["2.0.0"]}
                        }
                    ],
                    "references": [
                        {"url": "https://example.com/advisory"}
                    ],
                    "published": "2021-01-01T00:00:00Z"
                }
            ]
        }
        mock_post.return_value = mock_response

        vulns = self.scanner._query_osv_vulnerabilities(
            "test-package", "1.5.0", "PyPI"
        )

        self.assertEqual(len(vulns), 1)
        vuln = vulns[0]
        self.assertEqual(vuln.package_name, "test-package")
        self.assertEqual(vuln.installed_version, "1.5.0")
        self.assertEqual(vuln.vulnerability_id, "CVE-2021-12345")
        self.assertEqual(vuln.severity, Severity.HIGH)

    @patch('requests.post')
    def test_query_osv_vulnerabilities_no_results(self, mock_post):
        """Test OSV query with no vulnerabilities"""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"vulns": []}
        mock_post.return_value = mock_response

        vulns = self.scanner._query_osv_vulnerabilities(
            "safe-package", "1.0.0", "PyPI"
        )

        self.assertEqual(len(vulns), 0)

    @patch('requests.post')
    def test_scan_repository_integration(self, mock_post):
        """Test full repository scan integration"""
        # Create test files
        self._create_file("requirements.txt", "requests==2.25.0\nflask==1.1.0")
        self._create_file("package.json", json.dumps({
            "dependencies": {"express": "4.17.0"}
        }))

        # Mock OSV responses
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"vulns": []}
        mock_post.return_value = mock_response

        report = self.scanner.scan_repository(self.temp_dir)

        self.assertIsInstance(report, VulnerabilityReport)
        self.assertIsNotNone(report.summary)
        self.assertIsNotNone(report.scan_timestamp)
        self.assertGreater(len(report.scanned_files), 0)

    def test_vulnerability_to_dict(self):
        """Test Vulnerability to_dict method"""
        vuln = Vulnerability(
            package_name="test-package",
            installed_version="1.0.0",
            vulnerability_id="CVE-2021-12345",
            severity=Severity.HIGH,
            title="Test Vulnerability",
            description="Test description",
            fixed_version="2.0.0",
            cvss_score=7.5
        )

        result = vuln.to_dict()

        self.assertEqual(result['package_name'], "test-package")
        self.assertEqual(result['vulnerability_id'], "CVE-2021-12345")
        self.assertEqual(result['severity'], "HIGH")
        self.assertEqual(result['fixed_version'], "2.0.0")

    def test_vulnerability_fix_recommendation(self):
        """Test vulnerability fix recommendation generation"""
        vuln_with_fix = Vulnerability(
            package_name="vulnerable-pkg",
            installed_version="1.0.0",
            vulnerability_id="CVE-2021-11111",
            severity=Severity.HIGH,
            title="Test",
            description="Test",
            fixed_version="2.0.0"
        )

        vuln_no_fix = Vulnerability(
            package_name="vulnerable-pkg",
            installed_version="1.0.0",
            vulnerability_id="CVE-2021-22222",
            severity=Severity.HIGH,
            title="Test",
            description="Test",
            fixed_version=None
        )

        self.assertIn("Upgrade", vuln_with_fix.fix_recommendation)
        self.assertIn("2.0.0", vuln_with_fix.fix_recommendation)
        self.assertIn("No fix available", vuln_no_fix.fix_recommendation)

    def test_vulnerability_report_summary(self):
        """Test VulnerabilityReport summary calculation"""
        vulns = [
            Vulnerability("pkg1", "1.0", "CVE-1", Severity.CRITICAL, "t1", "d1"),
            Vulnerability("pkg2", "1.0", "CVE-2", Severity.CRITICAL, "t2", "d2"),
            Vulnerability("pkg3", "1.0", "CVE-3", Severity.HIGH, "t3", "d3"),
            Vulnerability("pkg4", "1.0", "CVE-4", Severity.MEDIUM, "t4", "d4"),
            Vulnerability("pkg5", "1.0", "CVE-5", Severity.LOW, "t5", "d5"),
        ]

        report = VulnerabilityReport(
            vulnerabilities=vulns,
            total_scanned=10
        )

        self.assertEqual(report.summary['total_vulnerabilities'], 5)
        self.assertEqual(report.summary['critical'], 2)
        self.assertEqual(report.summary['high'], 1)
        self.assertEqual(report.summary['medium'], 1)
        self.assertEqual(report.summary['low'], 1)

    def test_vulnerability_report_get_by_severity(self):
        """Test filtering vulnerabilities by severity"""
        vulns = [
            Vulnerability("pkg1", "1.0", "CVE-1", Severity.CRITICAL, "t1", "d1"),
            Vulnerability("pkg2", "1.0", "CVE-2", Severity.HIGH, "t2", "d2"),
            Vulnerability("pkg3", "1.0", "CVE-3", Severity.HIGH, "t3", "d3"),
        ]

        report = VulnerabilityReport(vulnerabilities=vulns)

        critical_vulns = report.get_by_severity(Severity.CRITICAL)
        high_vulns = report.get_by_severity(Severity.HIGH)

        self.assertEqual(len(critical_vulns), 1)
        self.assertEqual(len(high_vulns), 2)

    def test_scan_with_nested_requirements(self):
        """Test scanning with nested requirements directory"""
        os.makedirs(os.path.join(self.temp_dir, "requirements"), exist_ok=True)
        self._create_file("requirements/base.txt", "requests==2.25.0")
        self._create_file("requirements/dev.txt", "pytest==6.0.0")

        with patch.object(
            self.scanner,
            '_query_osv_vulnerabilities',
            return_value=[]
        ):
            vulns, scanned_files, count = self.scanner._scan_python(Path(self.temp_dir))

            # Should scan both files
            self.assertGreaterEqual(len(scanned_files), 2)


if __name__ == '__main__':
    unittest.main()
